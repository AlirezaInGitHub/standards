
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>API Reference</title>
    <link href="images/images/favicon.ico" rel="icon" type="image/ico" />

    <style>
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight .gh {
  color: #999999;
}
.highlight .sr {
  color: #f6aa11;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .nb {
  color: #f6aa11;
}
.highlight .cm {
  color: #75715e;
}
.highlight .cp {
  color: #75715e;
}
.highlight .c1 {
  color: #75715e;
}
.highlight .cs {
  color: #75715e;
}
.highlight .c, .highlight .cd {
  color: #75715e;
}
.highlight .err {
  color: #960050;
}
.highlight .gr {
  color: #960050;
}
.highlight .gt {
  color: #960050;
}
.highlight .gd {
  color: #49483e;
}
.highlight .gi {
  color: #49483e;
}
.highlight .ge {
  color: #49483e;
}
.highlight .kc {
  color: #66d9ef;
}
.highlight .kd {
  color: #66d9ef;
}
.highlight .kr {
  color: #66d9ef;
}
.highlight .no {
  color: #66d9ef;
}
.highlight .kt {
  color: #66d9ef;
}
.highlight .mf {
  color: #ae81ff;
}
.highlight .mh {
  color: #ae81ff;
}
.highlight .il {
  color: #ae81ff;
}
.highlight .mi {
  color: #ae81ff;
}
.highlight .mo {
  color: #ae81ff;
}
.highlight .m, .highlight .mb, .highlight .mx {
  color: #ae81ff;
}
.highlight .sc {
  color: #ae81ff;
}
.highlight .se {
  color: #ae81ff;
}
.highlight .ss {
  color: #ae81ff;
}
.highlight .sd {
  color: #e6db74;
}
.highlight .s2 {
  color: #e6db74;
}
.highlight .sb {
  color: #e6db74;
}
.highlight .sh {
  color: #e6db74;
}
.highlight .si {
  color: #e6db74;
}
.highlight .sx {
  color: #e6db74;
}
.highlight .s1 {
  color: #e6db74;
}
.highlight .s {
  color: #e6db74;
}
.highlight .na {
  color: #a6e22e;
}
.highlight .nc {
  color: #a6e22e;
}
.highlight .nd {
  color: #a6e22e;
}
.highlight .ne {
  color: #a6e22e;
}
.highlight .nf {
  color: #a6e22e;
}
.highlight .vc {
  color: #ffffff;
}
.highlight .nn {
  color: #ffffff;
}
.highlight .nl {
  color: #ffffff;
}
.highlight .ni {
  color: #ffffff;
}
.highlight .bp {
  color: #ffffff;
}
.highlight .vg {
  color: #ffffff;
}
.highlight .vi {
  color: #ffffff;
}
.highlight .nv {
  color: #ffffff;
}
.highlight .w {
  color: #ffffff;
}
.highlight {
  color: #ffffff;
}
.highlight .n, .highlight .py, .highlight .nx {
  color: #ffffff;
}
.highlight .ow {
  color: #f92672;
}
.highlight .nt {
  color: #f92672;
}
.highlight .k, .highlight .kv {
  color: #f92672;
}
.highlight .kn {
  color: #f92672;
}
.highlight .kp {
  color: #f92672;
}
.highlight .o {
  color: #f92672;
}
    </style>
    <link href="stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" media="print" />
      <script src="javascripts/all.js"></script>
  </head>

  <body class="index" data-languages="[&quot;swagger&quot;,&quot;shell&quot;,&quot;javascript&quot;]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" alt="Navbar" />
      </span>
    </a>
    <div class="toc-wrapper">
      <img src="images/logo.png" class="logo" alt="Logo" />
        <div class="lang-selector">
              <a href="#" data-language-name="swagger">swagger</a>
              <a href="#" data-language-name="shell">shell</a>
              <a href="#" data-language-name="javascript">javascript</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <ul id="toc" class="toc-list-h1">
          <li>
            <a href="#introduction" class="toc-h1 toc-link" data-title="Introduction">Introduction</a>
          </li>
          <li>
            <a href="#standards" class="toc-h1 toc-link" data-title="Standards">Standards</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#principles" class="toc-h2 toc-link" data-title="Principles">Principles</a>
                  </li>
                  <li>
                    <a href="#versioning" class="toc-h2 toc-link" data-title="Versioning">Versioning</a>
                  </li>
                  <li>
                    <a href="#uri-structure" class="toc-h2 toc-link" data-title="URI Structure">URI Structure</a>
                  </li>
                  <li>
                    <a href="#http-headers" class="toc-h2 toc-link" data-title="HTTP Headers">HTTP Headers</a>
                  </li>
                  <li>
                    <a href="#http-response-codes" class="toc-h2 toc-link" data-title="HTTP Response Codes">HTTP Response Codes</a>
                  </li>
                  <li>
                    <a href="#payload-conventions" class="toc-h2 toc-link" data-title="Payload Conventions">Payload Conventions</a>
                  </li>
                  <li>
                    <a href="#common-field-types" class="toc-h2 toc-link" data-title="Common Field Types">Common Field Types</a>
                  </li>
                  <li>
                    <a href="#pagination" class="toc-h2 toc-link" data-title="Pagination">Pagination</a>
                  </li>
                  <li>
                    <a href="#id-permanence" class="toc-h2 toc-link" data-title="ID Permanence">ID Permanence</a>
                  </li>
                  <li>
                    <a href="#extensibility" class="toc-h2 toc-link" data-title="Extensibility">Extensibility</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#security" class="toc-h1 toc-link" data-title="Security">Security</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#authorisation-scopes" class="toc-h2 toc-link" data-title="Authorisation Scopes">Authorisation Scopes</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#banking-apis" class="toc-h1 toc-link" data-title="Banking APIs">Banking APIs</a>
          </li>
          <li>
            <a href="#common-apis" class="toc-h1 toc-link" data-title="Common APIs">Common APIs</a>
          </li>
      </ul>
        <ul class="toc-footer">
            <li><a href='#'>Consumer Data Right Home</a></li>
            <li><a href='https://github.com/ConsumerDataStandardsAustralia/standards'>CDR Standards on GitHub</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <!---
TODO
- Add scopes to security
- Mock out APIs
--->
<h1 id='introduction'>Introduction</h1>
<p>These standards have been developed as part of the introduction in Australia of the <a href="https://www.accc.gov.au/focus-areas/consumer-data-right" title="ACCC Consumer Data Right webpage">Consumer Data Right</a> legislation to give Australians greater control over their data.</p>

<p>The Consumer Data Right is intended to apply sector by sector across the whole economy, beginning in the banking, energy and telecommunications sectors.  These standards have been developed to facilitate the Consumer Data Right by acting as a specific baseline for implementation.</p>

<p>These standards are governed by the Consumer Data Standards team inside Data61.  Data61 has been appointed as the interim standards body. The work of the team is  overseen by Mr. Andrew Stevens as interim Chair, with industry and consumer advice provided by an Advisory Committee. Data61 works closely with the Australian Competition and Consumer Commission (ACCC) as lead regulator of the Consumer Data Right, supported by the Office of the Australian Information Commissioner (OAIC).</p>
<h1 id='standards'>Standards</h1>
<p>These standards represent <strong>version 1</strong> of the high level standards.  See the <a href="#versioning">versioning section</a> for more information on how versions are managed in the standard.</p>

<p>Note that, in this proposal, the key words <strong>MUST</strong>, <strong>MUST NOT</strong>, <strong>REQUIRED</strong>, <strong>SHALL</strong>, <strong>SHALL NOT</strong>, <strong>SHOULD</strong>, <strong>SHOULD NOT</strong>, <strong>RECOMMENDED</strong>, <strong>MAY</strong>, and <strong>OPTIONAL</strong> are to be interpreted as described in <a href="http://tools.ietf.org/html/rfc2119">RFC2119</a>.</p>

<h2 id='principles'>Principles</h2>

<p>The following principles, classified as Outcome Principles and Technical Principles, are the basis for the development of the standards for the Consumer Data Right.</p>

<h3 id='outcome-principles'>Outcome Principles</h3>

<p>These principles articulate qualitative outcomes that the API definitions should seek to deliver.</p>

<h4 id='principle-1-apis-are-secure'>Principle 1: APIs are secure</h4>

<p>The API definitions will consider and incorporate the need for a high degree of security to protect customer data.  This includes the risk of technical breach but also additional concerns of inadvertent data leakage through overly broad data payloads and scopes.  The security of customer data is a first order outcome that the API standards must seek to deliver.</p>

<h4 id='principle-2-apis-use-open-standards'>Principle 2: APIs use open standards</h4>

<p>In order to promote widespread adoption, open standards that are robust and widely used in the industry will be used wherever possible.</p>

<h4 id='principle-3-apis-provide-a-good-customer-experience'>Principle 3: APIs provide a good customer experience</h4>

<p>The API definitions will consider and incorporate the customer experience implications.  The APIs should support the creation of customer experiences that are simple and enticing to use.</p>

<h4 id='principle-4-apis-provide-a-good-developer-experience'>Principle 4: APIs provide a good developer experience</h4>

<p>To ensure that the entry hurdle for new developers is low the experience of the developers that are building clients using the APIs will be considered.  The ability for a developer to easily understand and write code using the APIs in modern development environments should be facilitated by the API standards.</p>

<h3 id='technical-principles'>Technical Principles</h3>

<p>These principles articulate specific technical outcomes that the API definitions should seek to deliver.</p>

<h4 id='principle-5-apis-are-restful'>Principle 5: APIs are RESTful</h4>

<p>The API standards will adhere to RESTful API concepts where possible and sensible to do so.  In particular the concepts of statelessness and resource orientation will be followed.</p>

<h4 id='principle-6-apis-are-implementation-agnostic'>Principle 6: APIs are implementation agnostic</h4>

<p>The underlying implementation of the APIs should not be constrained or driven by the API definitions and standards.  Conversely, the underlying implementation choices should not be visible or derivable to the client applications using the APIs.</p>

<h4 id='principle-7-apis-are-simple'>Principle 7: APIs are simple</h4>

<p>As complexity will increase implementation costs for both providers and clients as well as reduce the utility of the APIs, API definitions should seek to be as simple as possible but no simpler.</p>

<h4 id='principle-8-apis-are-rich-in-capability'>Principle 8: APIs are rich in capability</h4>

<p>As the APIs are defined care should be taken to ensure that the data payloads defined represent rich data sets that can be used in many scenarios, including scenarios not necessarily front of mind during the design process.</p>

<h4 id='principle-9-apis-are-performant'>Principle 9: APIs are performant</h4>

<p>The API definitions should consider and incorporate performance implications during design ensuring that repeated calls are not necessary for simple use cases and that payload sizes do not introduce performance issues.</p>

<h4 id='principle-10-apis-are-consistent'>Principle 10: APIs are consistent</h4>

<p>The API definitions across the full suite of APIs should be consistent with each other as much as possible.  Where possible common data structures and patterns should be defined and reused.</p>

<h4 id='principle-11-apis-are-version-controlled-and-backwards-compatible'>Principle 11: APIs are version controlled and backwards compatible</h4>

<p>As the API definitions evolve care will be taken to ensure the operation of existing clients are protected when breaking changes occur.  Breaking changes will be protected by a well defined version control model and by a policy of whereby previous versions are maintained for a period of time to allow for backwards compatibility.</p>

<h4 id='principle-12-apis-are-extensible'>Principle 12: APIs are extensible</h4>

<p>The API definitions and standards should be built for extensibility.  This extensibility should accommodate future APIs categories and industry sectors but it should also allow for extension by data providers to create unique, value add offerings to the ecosystem.</p>

<h2 id='versioning'>Versioning</h2>

<p>The standards have adopted a two level versioning strategy.  The high level standards (including principles, URI structure, payload naming conventions, etc) be versioned and each API end point will have an additional version specific to that end point.</p>

<h3 id='standard-versioning'>Standard Versioning</h3>

<blockquote>
<p>The base URI structure containing the version for this standard is:<br>
<code>http://&lt;provider path&gt;/cds-au/v1/&lt;resource&gt;</code></p>
</blockquote>

<p>The high level standard will be versioned and this version will be in embedded in the <a href="#uri-structure">URI Structure</a> for the APIs.  This documentation relates specifically to <strong>version 1</strong> of the high level standards.</p>

<h3 id='end-point-versioning'>End Point Versioning</h3>

<p>Each end point will have multiple versions independent of other end points.  A specific end point version will be requested by a client using a HTTP header. This header will be supported by all end points under the API standards.  See the section on <a href="#http-headers">HTTP Headers</a> for more information on how versions are requested and supplied under the standards.</p>

<h2 id='uri-structure'>URI Structure</h2>

<blockquote>
<p>Some example URIs that meet this standard are:<br>
<code>http://www.bank.com.au/api/cds-au/v1/banking/accounts</code><br>
<code>http://www.bank.com.au/complex/uri/taxonomy/cds-au/v1/banking/products</code><br>
<code>http://www.energyretailer.com.au/api/cds-au/v1/energy/usage</code></p>
</blockquote>

<p>The URI structure for API end points in the standards MUST be implemented as follows:<br>
<code>&lt;provider path&gt; / cds-au / &lt;version&gt; / &lt;industry&gt; / &lt;resource&gt;</code></p>

<p>The components of this URI structure are described as follows:</p>

<ul>
<li><strong>Provider Path</strong>: The provider path is a base path set by the data provider. It can be any URI desired by the provider.</li>
<li><strong>“cds-au”</strong>: This is a static string representing the end points defined by the Consumer Data Standards for Australia. This static string allows for separation from other APIs available at the same base provider path and also allows for extension if the standards are adopted by another jurisdiction in whole or in part.</li>
<li><strong>Version</strong>: The version of the high level standards. This is not the version of the endpoint or the payload being requested but the version of the overall standards being applied. This version number will be “v” followed by a the version as a positive integer (e.g. v1, v12 or v76).</li>
<li><strong>Industry</strong>: A static string used to separate APIs for a specific industry. As standards for new industries are defined the list of industry strings will be extended.</li>
<li><strong>Resource</strong>: The URI for the specific resource requested. This end point URI will be defined as part of the end point definitions for each API group.</li>
</ul>

<p>Note that the currently accepted values for the <code>Industry</code> component of the base path are:</p>

<ul>
<li><strong>banking</strong> – for APIs related to banking and potentially wider financial services data</li>
<li><strong>energy</strong> – for APIs related to the energy distribution industry</li>
<li><strong>telco</strong> – for APIs related to telecommunications</li>
<li><strong>common</strong> – for APIs that potentially span industries</li>
</ul>

<h3 id='resource-uris'>Resource URIs</h3>

<p>Resources that are collections, and members of collections, will follow the <a href="http://jsonapi.org">JSONAPI.org</a> recommendation.</p>

<p>Under this model collections, individual members and collection sub-resources would be accessed as follows:</p>

<table><thead>
<tr>
<th><a href="#"></a></th>
<th><a href="#"></a></th>
</tr>
</thead><tbody>
<tr>
<td><code>GET …\accounts</code></td>
<td>Returns an array of accounts</td>
</tr>
<tr>
<td><code>GET …\accounts\{id}</code></td>
<td>Returns the detail of a specific account</td>
</tr>
<tr>
<td><code>GET …\accounts\transactions</code></td>
<td>Returns the transactions of multiple accounts</td>
</tr>
<tr>
<td><code>GET …\accounts\{id}\transactions</code></td>
<td>Returns the transactions of a specific account</td>
</tr>
<tr>
<td><code>POST …\accounts</code></td>
<td>Create a new account</td>
</tr>
<tr>
<td><code>POST …\accounts\search</code></td>
<td>Returns an array of accounts based on a complex query</td>
</tr>
</tbody></table>

<p>The final example above represents a complex query accessed via a POST request.  In this situation the POST URI should be applied to a sub-resource of the collection.  A POST to a collection is reserved for the creation of a new collection member</p>

<p>If no valid sub-resource exists then a dedicated sub-resource should be created, such as the “search” URI listed in the example above.</p>

<h2 id='http-headers'>HTTP Headers</h2>

<p>Supported HTTP headers, and there usage, for the standards are as laid out in the following sections.</p>

<h3 id='request-headers'>Request Headers</h3>

<blockquote>
<p>A sample set of headers requesting version 3 to 5:<br>
<code>Content-Type = application/json</code><br>
<code>Accept = application/json</code><br>
<code>x-v = 5</code><br>
<code>x-min-v = 3</code><br>
<code>x-Correlation-Id = 27639FAB67CC</code></p>
</blockquote>

<table><thead>
<tr>
<th>Header Field</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td><strong>Content-Type</strong></td>
<td>Standard HTTP Header. Represents the format of the payload provided in the request. Must be set to <code>application/json</code>.</td>
</tr>
<tr>
<td><strong>Accept</strong></td>
<td>Standard HTTP Header. Specify the Content-Type that is required from the Server.<br/>If specified, must be set to <code>application/json</code> unless otherwise specified in the resource end point standard.<br/>If set to an unacceptable value the provider must respond with a 406 Not Acceptable. If not specified, default is <code>application/json</code>.</td>
</tr>
<tr>
<td><strong>x-v</strong></td>
<td>Version of the API end point requested by the client. Must be set to a positive integer.<br/>If the version(s) requested is not supported then the provider should respond with a <code>406 Not Acceptable</code>.</td>
</tr>
<tr>
<td><strong>x-min-v</strong></td>
<td>Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The provider should respond with the highest supported version between <code>x-min-v</code> and <code>x-v</code>.<br/>If all versions requested are not supported then the provider should respond with a <code>406 Not Acceptable</code>.</td>
</tr>
<tr>
<td><strong>x-&lt;PID&gt;-v</strong></td>
<td>A provider specific version of extension fields. Should not be used in conjunction with <code>x-min-v</code>.</td>
</tr>
<tr>
<td><strong>x-Correlation-Id</strong></td>
<td>Optional correlation ID provided by the data consumer that should be reflected back in the response headers. Can be used for reporting and logging.</td>
</tr>
</tbody></table>

<h3 id='response-headers'>Response headers</h3>

<table><thead>
<tr>
<th>Header Field</th>
<th>Description</th>
<th>Mandatory?</th>
</tr>
</thead><tbody>
<tr>
<td><strong>Content-Type</strong></td>
<td>Standard HTTP Header. Represents the format of the payload returned in the response.<br/>Must be <code>application/json</code> unless otherwise specified in the resource end point standard.</td>
<td>Mandatory</td>
</tr>
<tr>
<td><strong>Retry-After</strong></td>
<td>Header indicating the time (in seconds) that the client should wait before retrying an operation. The provider should include this header along with responses with the HTTP status code of <code>429 Too many requests</code>.</td>
<td>Optional</td>
</tr>
<tr>
<td><strong>x-v</strong></td>
<td>The version of the API end point that the provider has responded with.</td>
<td>Mandatory</td>
</tr>
<tr>
<td><strong>x-Correlation-Id</strong></td>
<td>Reflected value of the correlation ID provided by the data consumer in the request headers.<br/>If no correlation ID was provided in the request this header should not be supplied.<br/>If a correlation ID was provided in the request then this header is mandatory.</td>
<td>Optional</td>
</tr>
</tbody></table>

<h3 id='additional-headers'>Additional Headers</h3>

<p>Generally understood headers used in HTTP transactions to provide caching guidance and the use of the compression are not specified but are considered acceptable. It is at the discretion of the data provider if these headers are used for a specific implementation. Data providers should not require these headers for successful API access, however.</p>

<h2 id='http-response-codes'>HTTP Response Codes</h2>

<p>The handling and usage of HTTP response codes for the standards will be according to the following table.</p>

<table><thead>
<tr>
<th>Situation</th>
<th>HTTP Status</th>
<th>Notes</th>
<th>POST</th>
<th>GET</th>
<th>DELETE</th>
</tr>
</thead><tbody>
<tr>
<td>Query completed successfully</td>
<td>200 OK</td>
<td></td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Normal execution. The request has succeeded.</td>
<td>201 Created</td>
<td>The operation results in the creation of a new resource.</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>Delete operation completed successfully</td>
<td>204 No Content</td>
<td></td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Request has malformed, missing or non-compliant JSON body or URL parameters</td>
<td>400 Bad Request</td>
<td>The requested operation will not be carried out.</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Authorization header missing or invalid token</td>
<td>401 Unauthorized</td>
<td>The operation was refused access. Re-authenticating may result in an appropriate token that may be used.</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Token has incorrect scope or a security policy was violated.</td>
<td>403 Forbidden</td>
<td>The operation was refused access. Re-authenticating is unlikely to remediate the situation.</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>The consumer tried to access the resource with a method that is not supported.</td>
<td>405 Method Not Allowed</td>
<td></td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>The request contained an Accept header other than permitted media types, a character set other than UTF-8 or a version that was not supported</td>
<td>406 Not Acceptable</td>
<td></td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>The operation was refused because the payload is in a format not supported by this method on the target resource.</td>
<td>415 Unsupported Media Type</td>
<td></td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>The request was well formed but was unable to be processed due to business logic specific to the request</td>
<td>422 Unprocessable Entity</td>
<td></td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>The operation was refused as too many requests have been made within a certain timeframe.</td>
<td>429 Too Many Requests</td>
<td>Throttling is a NFR. The data provider should include a Retry-After header in the response indicating how long the data consumer must wait before retrying the operation.</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Something went wrong on the API gateway or micro-service</td>
<td>500 Internal Server Error</td>
<td>The operation failed.</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Service is currently unavailable</td>
<td>503 Service Unavailable</td>
<td></td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>The server was unable to respond in a timely manner</td>
<td>504 Gateway Timeout</td>
<td>Returned if a timeout has occurred but a resend of the original request is viable (otherwise us 500 instead)</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>

<h2 id='payload-conventions'>Payload Conventions</h2>

<p>This section of the standard outlines the request and response payload structures for all API end points as well as the naming conventions for fields.</p>

<h3 id='request-payload-structure'>Request Payload Structure</h3>

<blockquote>
<p>A sample request would be structured as follows:</p>
</blockquote>

<pre class="highlight plaintext"><code>{
  “data”: {
    ...
  }
  “meta”: {
    ...
  }
}
</code></pre>

<p>Each API request payload MUST have a JSON object at the root level known as the <strong>root object</strong>. This object MUST contain a <code>data</code> object to hold the primary data for the request.</p>

<p>The root object will contain a <code>meta</code> object if, and only if, it is specifically REQUIRED by the end point. The meta object is used to provide additional information such as second factor authorisation data, traffic management, pagination counts or other purposes that are complementary to the workings of the API.</p>

<p>The definition of the contents for the <code>data</code> object and <code>meta</code> object will be defined separately for each end point.</p>

<h3 id='response-payload-structure'>Response Payload Structure</h3>

<blockquote>
<p>A sample successful response:</p>
</blockquote>

<pre class="highlight plaintext"><code>{
  “data”: {
    ...
  }
  “links”: {
    “self”: “...”
  }
  “meta”: {
    ...
  }
}
</code></pre>

<blockquote>
<p>A sample unsuccessful response:</p>
</blockquote>

<pre class="highlight plaintext"><code>{
  “errors”: [
    {
      “code”: “...”,
      “title”: “...”,
      “detail”: “...”
    }, {
      “code”: “...”,
      “title”: “...”,
      “detail”: “...”,
      “meta”: {
        ...
      }
    }
  ]
}
</code></pre>

<p>Each API request payload MUST have a JSON object at the root level known as the <strong>root object</strong>.</p>

<p>The contents of the root object are as follows:</p>

<ul>
<li>If the response is successful (200 OK) the root object:

<ul>
<li>MUST contain a <code>data</code> object</li>
<li>MUST contain a <code>links</code> object</li>
<li>MAY contain a <code>meta</code> object if REQUIRED by the definition of the specific end point</li>
</ul></li>
<li>If the response is unsuccessful (not 200 OK) the root object:

<ul>
<li>MUST contain an <code>errors</code> object</li>
</ul></li>
</ul>

<p>The definition of the contents for the <code>data</code> object and <code>meta</code> object will be defined separately for each end point.</p>

<p>The <code>links</code> object will contain links to related API end points. This will include links to support pagination.</p>

<p>The links object MUST contain a field named <code>self</code> that will have the fully qualified URI to the current request as a value.</p>

<p>The <code>errors</code> object will be an array of zero or more unnamed objects. The fields in each of these objects will be as follows:</p>

<ul>
<li><code>code</code> field MUST be present: holds an end point specific error code</li>
<li><code>title</code> field MUST be present: holds a human readable label of the error that is constant
per code</li>
<li><code>detail</code> field MUST be present: holds a human readable description of this specific error</li>
<li><code>meta</code> object MAY be present: holds additional end point specific data relevant to the error</li>
</ul>

<h3 id='field-naming-conventions'>Field Naming Conventions</h3><h4 id='valid-characters-in-field-names'>Valid Characters In Field Names</h4>
<p>All field names defined in either a request or response payload MUST be treated as case sensitive by clients and servers, and they MUST meet all of the following conditions:</p>

<ul>
<li>Member names MUST contain at least one character.</li>
<li>Member names MUST contain only the allowed characters listed below:

<ul>
<li>U+0061 to U+007A, <strong>a-z</strong></li>
<li>U+0041 to U+005A, <strong>A-Z</strong></li>
<li>U+0030 to U+0039, <strong>0-9</strong></li>
</ul></li>
<li>Additionally, the following characters are allowed in field names, except as the first or last character:

<ul>
<li>U+002D HYPHEN-MINUS, &#39;<strong>-</strong>&#39;</li>
<li>U+005F LOW LINE, &#39;<strong>_</strong>&#39;</li>
<li>U+0024 DOLLAR SIGN, &#39;<strong>$</strong>&#39;</li>
</ul></li>
</ul>

<p>Any other character MUST NOT be used in field names.</p>
<h4 id='field-naming-style'>Field Naming Style</h4>
<p>Field names MUST be meaningful names with defined semantics.</p>

<p>Fields representing the same data in different payloads or different parts of a payload MUST have
the same name.</p>

<p>Array types SHOULD have plural field names. All other field names SHOULD be singular.</p>

<p>Field names MUST be defined using camel case with the following clarifications:</p>

<ul>
<li>If a field name is a single acronym it SHOULD be lowercase</li>
<li>If a field name contains an acronym along with other words it MAY be uppercase</li>
<li>The first character in a field name SHOULD be lower case unless it is part of an acronym</li>
</ul>

<p>Fields MUST NOT be named using reserved javascript tokens.</p>
<h4 id='maps'>Maps</h4>
<p>For JSON maps (i.e. key/value pairs) any Unicode character MAY be used as a field name and stylistic requirements do not apply.</p>
<h3 id='field-property-conventions'>Field Property Conventions</h3><h4 id='field-data-types'>Field Data Types</h4>
<p>Each field defined for the payloads of an end point MUST have an assigned data type.</p>

<p>The list of valid data types are set out in the <a href="#common-field-types">common field types</a> section. If a custom data type is required for a field then the field SHOULD be classified as a string with a clear description of how the property value is to be interpreted or defined.</p>
<h4 id='mandatory-optional-fields'>Mandatory/Optional Fields</h4>
<p>Each field defined for the payloads of an end point MUST have an assigned status of mandatory, optional or conditional.</p>

<p>Mandatory fields MUST be present and have a non-null value in a request or response payload for the payload to be considered valid.</p>

<p>Optional fields MAY be present but this is not guaranteed. It is also valid for these fields to be present but have a null value.</p>

<p>Conditional fields MUST have an associated conditional statement. If the conditional statement is true in a specific request or response the field is considered mandatory. If the conditional statement is false then the field is considered optional.</p>
<h4 id='empty-null-fields'>Empty/Null Fields</h4>
<p>An empty field (ie. a field that is not present in a payload) will be considered equivalent with a field that is present with a <code>null</code> value.</p>

<p>An empty string (<code>“”</code>) is not considered to be equivalent to <code>null</code>.</p>

<p>A Boolean value of false is not considered to be equivalent to <code>null</code>. Optional Boolean fields, by implication, have three possible values: true, false and indeterminate (ie. <code>null</code>).</p>
<h3 id='object-conventions'>Object conventions</h3>

<blockquote>
<p>Sample union object structure:</p>
</blockquote>

<pre class="highlight plaintext"><code>“data”: {
    [
        {
            “shape$type”: “circle”,
            “circle”: {
            }
        },
        {
            “shape$type”: “square”,
            “square”: {
            }
        }
    ]
}
</code></pre>

<p>A specific convention will apply to union objects.</p>

<p>In the standards a union object is used in a situation where a set of data can be represented with different sets of fields depending on the context.  To maintain strong typing of the fields one of a series of known object structures will be used.  An example where this technique is used in the standard is in the definition of account balances where balance information can be represented differently, but unambiguously, for different account types.</p>

<p>For union objects an additional field, with a known suffix, is used to identify the object type that has been provided specifically.</p>

<p>As the name of this field is constant it can be used to perform an indirect lookup on the object type that has actually been provided removing the need to scan for which object is present.</p>

<p>A field of this type could be specified to always have the suffix <code>$type</code>.</p>

<h2 id='common-field-types'>Common Field Types</h2>

<p>The following table outlines the common data types for fields used in the standard.</p>

<table><thead>
<tr>
<th>Type</th>
<th>Description</th>
<th>Valid Examples</th>
</tr>
</thead><tbody>
<tr>
<td>String</td>
<td>Standard UTF-8 string but unrestricted in content. Any valid Unicode character can be used.</td>
<td></td>
</tr>
<tr>
<td>ASCIIString</td>
<td>Standard UTF-8 string but limited to the ASCII character set.</td>
<td></td>
</tr>
<tr>
<td>Boolean</td>
<td>Standard JSON boolean</td>
<td>true<br/>false</td>
</tr>
<tr>
<td>Enum</td>
<td>String representing an option from a defined list of values<br/>- All possible values should be provided<br/>- Values should be in all caps<br/>- Spaces should be replaced with under bars &#39;_&#39;<br/>- Values should be limited to the ASCII character set</td>
<td>“OPTION1”<br/>“ANOTHER_OPTION”<br/>“VAL_ABC_123”</td>
</tr>
<tr>
<td>PositiveInteger</td>
<td>A positive integer inclusive of zero</td>
<td>0<br/>1<br/>10000</td>
</tr>
<tr>
<td>NegativeInteger</td>
<td>A negative integer inclusive of zero</td>
<td>0<br/>-1<br/>-10000</td>
</tr>
<tr>
<td>Integer</td>
<td>Any positive or negative integer inclusive of zero</td>
<td>1<br/>0<br/>-1</td>
</tr>
<tr>
<td>Number</td>
<td>A standard floating point number. Can be positive, negative or zero</td>
<td>0.1<br/>-100.09<br/>10<br/>90.09</td>
</tr>
<tr>
<td>DateTimeString</td>
<td>Combined Date and Time string as per RFC- 3339 (labelled date-time in the RFC)</td>
<td>“2007-05-01T15:43:00.12345Z”<br/>“2012-12-25T15:43:00-08:00”<br/>“1997-01-12T15:43:00.121Z”</td>
</tr>
<tr>
<td>DateString</td>
<td>Date string as per RFC-3339 (labelled full-date in the RFC). UTC time should always be used</td>
<td>“2007-05-01”<br/>“2012-12-25”</td>
</tr>
<tr>
<td>TimeString</td>
<td>Time string as per RFC-3339 (labelled full-time in the RFC). UTC time should always be used</td>
<td>“15:43:00.12345Z”<br/>“15:43:00-12:00”</td>
</tr>
<tr>
<td>CurrencyString</td>
<td>Standard 3 character currency codes as per ISO-4217</td>
<td>“AUD”<br/>“USD”<br/>“GBP”</td>
</tr>
<tr>
<td>RateString</td>
<td>A string representing a percentage interest rate<br/>- A positive number (or zero)<br/>- At least 1 and up to a total of 16 significant digits before decimal point<br/>- Up to 16 digits following the decimal point<br/>- No formatting, eg thousand separating commas</td>
<td>“82”<br/>“0.05”<br/>“12.3456789”<br/>“99.123456789123”</td>
</tr>
<tr>
<td>AmountString</td>
<td>A string representing an amount of currency.<br/>- A positive, zero or negative number<br/>- Negative numbers identified with a ‘-‘<br/>- No currency symbols should be supplied<br/>- At least 1 and up to a total of 16 significant digits before decimal point<br/>- Minimum 2 digits following a decimal point (more digits allowable but only if required)<br/>- No additional formatting, eg thousand separating commas</td>
<td>“0.01”<br/>“10.00”<br/>“1234567.89”<br/>“-1001.23”<br/>“1.999”</td>
</tr>
<tr>
<td>MaskedPANString</td>
<td>Masked credit card number. Lower case ‘x’ should be used to mask numbers and only the last four digits should be exposed to facilitate identification.</td>
<td>&quot;xxxxxxxxxxxx1234&quot;</td>
</tr>
</tbody></table>

<h2 id='pagination'>Pagination</h2>

<p>Each API end point that can return multiple records will stipulate whether pagination is supported for the end point or not. For end points that will return less than a reasonably sized page of results in the majority of circumstances support for paging may not be included.</p>

<p>Note that the use of paging for an end point does not require or preclude the use of filtering query parameters. It is expected that filtering and paging will be applied independently of each other.</p>

<h3 id='query-parameters'>Query Parameters</h3>

<p>The consumer will stipulate pagination requirements on the request using query parameters. When paging is supported the consumer MAY provide the following query parameters:</p>

<ul>
<li><strong>page</strong> – the page number being requested (with the first page being 1)</li>
<li><strong>pageSize</strong> – the number of records to return in each page</li>
</ul>

<p>If the query parameters are not provided the following defaults will be assumed:</p>

<ul>
<li><strong>page</strong> – a default of 1 (the first page) will be assumed</li>
<li><strong>pageSize</strong> – a default of 25 will be assumed</li>
</ul>

<h3 id='response-fields'>Response Fields</h3>

<p>In addition to the data requested a provider MUST provide the following additional information in the response payload:</p>

<ul>
<li>In the links object the following fields are to be provided:

<ul>
<li><strong>first</strong> - A URI to request the first page. This field MUST be present.</li>
<li><strong>last</strong> -  A URI to request the last page. This field MUST be present unless there is only one page in the set.</li>
<li><strong>prev</strong> - A URI to the previous page. This field MUST be present unless the current page is the first page.</li>
<li><strong>next</strong> - A URI to the next page. This field MUST be present unless the current page is the final page.</li>
</ul></li>
<li>In the <code>meta</code> object the following fields are to be provided:

<ul>
<li><strong>totalRecords</strong> - The total number of records in the set. This field MUST be present.</li>
<li><strong>totalPages</strong> - The total number of pages in the set. This field MUST be present.</li>
</ul></li>
</ul>

<p>For each of these fields the page size specified in the request should be assumed when calculating
values.</p>

<h3 id='additional-pagination-rules'>Additional Pagination Rules</h3>

<ul>
<li>Providers are not expected to implement pagination with transaction isolation. The underlying data-set may change between two subsequent requests. This may result in situations where the same transaction is returned on more than one page.</li>
<li>A maximum page size of <code>1000</code> records is assumed for all end points (unless otherwise stipulated in the end point definition). If a page size greater than this maximum is requested then a HTTP status of <code>422 Unprocessable Entity</code> SHOULD be returned.</li>
</ul>

<h2 id='id-permanence'>ID Permanence</h2>

<p>Within these standards resource IDs are REQUIRED to comply with the following:</p>

<ul>
<li>An ID for a resource should only be specified in the API standard if an end point exists to
obtain detail for that resource or to change the state of the resource.</li>
<li>If an ID is specified in the standards for a resource then it is mandatory and MUST be
supplied, by the data provider, in accordance with the standards.</li>
<li>If an ID is specified the ID value MUST be entirely arbitrary and have no inherent meaning. For instance, an ID should not be a combination of other fields or a string that can be parsed to extract meaningful information.</li>
<li>IDs SHOULD be unique but that uniqueness may be within a clearly bounded context. For example, a beneficiary ID may be unique but only in the context of a specific account. The bounds of uniqueness should be clearly described in the standards definition for the end point.</li>
<li>IDs MUST be immutable across sessions but MUST NOT be transferable across data consumers. For example, data consumer A obtaining an account ID would get a different result from data consumer B obtaining the ID for the same account even if the same customer authorised the access. Under this constraint IDs cannot be usefully transferred between client organisations or providers.</li>
<li>IDs MUST NOT be transferable between different customers for the same data consumer. For example, a data consumer should obtain a different ID for a joint account if the ID was obtained independently using authorisations from both customers.</li>
<li>In payloads the field name of “id” should NEVER be used. Each ID field should be meaningfully named so that wherever that ID is used across multiple end points it always refers to the same ID set. For instance, the IDs for accounts would be represented in JSON in a field named “accountId”.</li>
</ul>

<h2 id='extensibility'>Extensibility</h2>

<p>The Consumer Data Right standards will not cover all possible data sets or APIs that participants may wish to expose. Participants may also wish to innovate on top of the API standards by offering additional data to meet specific market opportunities. It is desirable that the standards not only allow for this to occur but actively encourage it with specific additions to the standards to enable such extension.</p>

<p>At the same time, it is important that a participant seeking to provide extensions does not hinder a data consumer that is only built for the published standards.</p>

<p>To accommodate these concerns the standards incorporate the following considerations specifically related to extension by data providers.</p>

<p>The three types of extension that the standards address are:</p>

<ol>
<li>Data provider offering entirely new API categories that are not covered by the API Standards</li>
<li>Data provider offering additional end points to an API category that is already covered by the standards</li>
<li>Data provider offering additional fields to the response payloads for an end point defined in the
standards</li>
</ol>

<h3 id='provider-identifier'>Provider Identifier</h3>

<blockquote>
<p>For example, the prefixes for the four major Banks required to implement by 1st July 2019 would be:
<ul>
<li>CBA – Commonwealth Bank</li>
<li>WBC – Westpac Banking Corporation</li>
<li>ANZ – ANZ Banking Group</li>
<li>NAB – National Australia Bank</li>
</ul></p>
</blockquote>

<p>Data providers seeking to extend the standards MUST nominate a prefix to identify all extensions.  Extended fields and end points and would use this prefix consistently. This prefix would be, by preference, the ASX symbol for the provider. Care should be taken not to use a prefix already adopted by another provider in the regime.</p>

<p>In these standards, where a Provider Identifier would be included, the term <code>&lt;PID&gt;</code> will be used.</p>

<h3 id='new-api-categories'>New API Categories</h3>

<p>When extending by adding new API categories a provider MUST add these to the overall URI structure by substituting the industry element with the Provider ID.</p>

<p>For instance, the standard URI base path is structured as:<br>
<code>&lt;provider path&gt; / cds-au / &lt;version&gt; / &lt;industry&gt; / &lt;resource&gt;</code></p>

<p>For the extension API categories for a specific provider they would be structured as:<br>
<code>&lt;provider path&gt; / cds-au / &lt;version&gt; / &lt;PID&gt; / &lt;resource&gt;</code></p>

<p>The end points defined under this structure, including the payloads of these end points do not need to be prefixed in any way. The fact that they are underneath the provider section implies that they are additional to the standard.</p>

<p>Note that:</p>

<ul>
<li>This mechanism MUST NOT be used to create modified duplicates of the end points defined in the API Standards</li>
<li>The end points in this area MUST comply with the overall standards including naming conventions and data types.</li>
</ul>

<h3 id='new-end-points-in-existing-api-categories'>New End Points In Existing API Categories</h3>

<p>When creating new end points that are in parallel to existing API categories in the standard the Provider Identifier MUST be used to prefix the highest URI element where divergence occurs.</p>

<p>For example, assume an existing balance end point is defined as follows:<br>
<code>&lt;base path&gt;/accounts/{account ID}/transactions</code></p>

<p>and the provider wishes to add an end point that summarises balance movement for a specific time period then they may define the end point as:<br>
<code>&lt;base path&gt;/account/{account ID}/&lt;PID&gt;-balance-movement</code></p>

<p>Note that:</p>

<ul>
<li>The prefix is defined as the Provider Identifier followed by a hyphen.</li>
<li>As the entire end point is new, the request and payload fields do not need to be prefixed in any way.</li>
<li>Care should be taken to ensure there is no collision with an end point defined in the standards by specifying an extension at the same level as a variable URI element (such as at the same level of the {account ID} in the example above).</li>
<li>If an end point has multiple levels in the resource path only the highest point where divergence with the standard occurs needs to be prefixed.</li>
<li>The new end point MUST comply with the overall standards including naming conventions and data types.</li>
</ul>

<h3 id='additional-fields-in-an-existing-response-payload'>Additional Fields In An Existing Response Payload</h3>

<p>When adding a new field in an existing payload the field can be added to the JSON by prefixing the string <code>&lt;PID&gt;-</code>.</p>

<p>If an object is being added as an extension only the highest level object name needs to be prefixed. Any fields inside the extended object can be named normally.</p>

<p>Note that:</p>

<ul>
<li>Existing fields MUST NOT be modified in any way. This includes adding new enumeration values to enum type fields.</li>
<li>A mandatory field MUST NOT be made optional as the result of an extension.</li>
<li>Request payloads can also be extended but the resulting end point should still execute successfully if the extension field is not present (by implication, extension fields in request payloads MUST be optional).</li>
<li>New query parameters MAY be added along the same lines as a new field in a request payload (i.e. prefixed, non-mandatory and no side effects if not present).</li>
<li>New headers MAY be added along the same lines as a new field in a request payload with the exception that the new header should be prefixed <code>x-&lt;PID&gt;-</code>.</li>
<li>New fields MUST comply with the overall naming conventions and data type standards used.</li>
</ul>

<h3 id='extension-versioning'>Extension Versioning</h3>

<p>As described previously in the <a href="#versioning">versioning section</a> the standard provides for multiple versions of each API end point.  This implies the need for extensions to also be versioned.</p>

<p>An optional header <code>x-&lt;PID&gt;-v</code> will be supported for all end points that can be used by the data consumer to request a specific version of extension fields to include in the response.  See the section on <a href="#http-headers">HTTP Headers</a> for more information on the use of this header.</p>
<h1 id='security'>Security</h1>
<aside class="warning">
This section is still under development as a series of decision proposals progress to finalisation.<br/>
<br/>
Where content is present it represents decisions that have been completed.
</aside>

<h2 id='authorisation-scopes'>Authorisation Scopes</h2>

<p>The following authorisation scopes have been defined for the standards.  Each API end point will specify which scopes are required to access the data available via that end point.</p>

<table><thead>
<tr>
<th>Scope Name</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td><strong>Basic Bank Account Data</strong></td>
<td>This scope would allow for the third party to access basic information of the customer’s accounts.<br/><br/>Includes simple account information including balance.<br/>Does not include account identifiers, product information or transaction data.</td>
</tr>
<tr>
<td><strong>Detailed Bank Account Data</strong></td>
<td>This scope would allow for the third party to access detailed information of the customer’s accounts. This scope is effectively additional authorisation to the Basic Bank Account Data scope. Granting this authorisation only makes sense if the Bank Account Data scope is also authorised.<br/><br/>Includes basic account information plus account identifiers and product information.<br/>Does not include transaction data.</td>
</tr>
<tr>
<td><strong>Bank Transaction Data</strong></td>
<td>This scope would allow the third party to access transaction data for accounts.  This scope is effectively additional authorisation to the Basic Bank Account Data scope.  Granting this authorisation only makes sense if the Basic Bank Account Data scope is also authorised.<br/><br/>Includes all account transaction data.</td>
</tr>
<tr>
<td><strong>Bank Payee Data</strong></td>
<td>This scope allows access to payee information stored by the customer.<br/><br/>Includes payee information such as billers, international beneficiaries and domestic payees.</td>
</tr>
<tr>
<td><strong>Customer Data</strong></td>
<td>The scope would allow the third party to access personally identifiable information about the customer.  For retail customers this would be information about the customer themselves.  For business customers it would imply information about the specific user but also information about the business.<br/><br/>Includes name, date of birth and contact information.</td>
</tr>
<tr>
<td><strong>Public</strong></td>
<td>Openly accessible information.  A customer would never need to grant this scope.  This scope is included so that end points that can be called without requiring authorisation can be identified.<br/><br/>Includes access to openly available information such as generic product information.</td>
</tr>
</tbody></table>
<h1 id='banking-apis'>Banking APIs</h1>
<aside class="warning">
This section is still under development as the API end points and payloads have not yet been finalised.<br/>
</aside>

<!-- Accounts -->

<!-- Direct Debits -->

<!-- Scheduled Payments -->

<!-- Payees -->
<h1 id='common-apis'>Common APIs</h1>
<aside class="warning">
This section is still under development as the API end points and payloads have not yet been finalised.<br/>
</aside>

<!-- Customer -->

      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="swagger">swagger</a>
                <a href="#" data-language-name="shell">shell</a>
                <a href="#" data-language-name="javascript">javascript</a>
          </div>
      </div>
    </div>
  </body>
</html>
